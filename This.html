<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Edwin Cortazo">

<title>Replication [Draft]</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="This_files/libs/clipboard/clipboard.min.js"></script>
<script src="This_files/libs/quarto-html/quarto.js"></script>
<script src="This_files/libs/quarto-html/popper.min.js"></script>
<script src="This_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="This_files/libs/quarto-html/anchor.min.js"></script>
<link href="This_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="This_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="This_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="This_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="This_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Replication [Draft]</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Edwin Cortazo </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<!--- Data Exclusion -->
<!--- Behavioral Data -->
<!--- EEG Data -->
<!--- Fashion word v non-word at Pz -->
<!--- (MORAL) category v non-category at Cz -->
<!--- (FASHION) category v non-category at Cz -->
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This is a replication of the study by Gantman et al (2020). Replication studies play a crucial role in ensuring the reliability and valor of scientific findings. By conducting replications, researchers can assess the generality of previous results and confirm replicability. Replications also serve to identify potential sources of variation and confounding factors. In this study, we aim to replicate the findings of Gantman et al.&nbsp;(2020), who investigated the “moral pop-out effect” using event-related potentials (ERPs).</p>
<p>The moral pop-out effect suggests that the “morality” of a visual stimulus is prioritized in the early stages of perception, leading to faster recognition of moral words compared to non-moral words. Gantman et al.&nbsp;(2020) found marginal support for this effect, with participants responding slightly faster to moral words than non-moral words, although the difference was not statistically significant. They also observed that moral and non-moral words were distinguishable from one another as early as 300 ms after word presentation.</p>
<p>However, it remains unclear whether this effect is specific to the moral domain or if it the observed effect could instead be explained by semantic priming resulting from seeing moral words repeatedly throughout the experiment. To account for this potential confound, we aim to replicate the study by incorporating an additional category of fashion words, as suggested by Firestone and Scholl (2015). If the pop-out effect holds true, we expect to replicate the behavioral and ERP effects for moral but not fashion words. By including this control condition and directly comparing moral and fashion words, this study aims to provide a more comprehensive understanding of the intricacies and nature of the moral pop-out effect and ensure the robustness of the original findings.</p>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="participants" class="level2">
<h2 class="anchored" data-anchor-id="participants">Participants</h2>
<p>46 native English-speaking Vassar College students participated in this study. Participants were aged 18 years or older and had normal or corrected vision and provided informed consent prior to the experiment. Participants were compensated with $20 and in some cases, course credit upon completion of experiment. This study was approved by the Vassar College Institutional Review Board. After applying the exclusion criteria, 34 subjects remain. 7 subjects were excluded for receiving fashion words twice due to a technical error, 1 subject was excluded for having poor EEG recordings, 0 were excluded for failing to reply more than 50% of trials and 0 were excluded for having a non-word response greater than 90%.</p>
</section>
<section id="materials" class="level2">
<h2 class="anchored" data-anchor-id="materials">Materials</h2>
<p>The experiment was designed using jsPsych(<a href="www.jspsych.org">www.jspsych.org</a>) and utilized subsets of stimuli (word lists) from Gantman et al.&nbsp;(2020) and Firestone and Scholl (2015). The stimuli consisted of eight distinct categories: non-moral words, moral words, non-moral non-words, moral non-words, fashion words, fashion non-words, non-fashion words, and non-fashion non-words. Non-words were created by scrambling the letters of corresponding words.</p>
<p>The experiment was conducted using and ASUS VG248QE monitor with full HD 1080p resolution and a 144hz refresh rate. Participants used a Lenovo SK-8825 (L) wired black USB keyboard for response inputs. EEG data was recorded using a CGX Quick-20r wireless, battery-operated, full standard 10-20 montage EEG headset with dry sensor technology, sampling at 500Hz with 24-bit resolution. A CGX Wireless Stim Trigger was used for 16-bit simultaneous event marking with millisecond precision.</p>
</section>
<section id="procedure" class="level2">
<h2 class="anchored" data-anchor-id="procedure">Procedure</h2>
<p>Participants completed the experiment individually in 90 minute sessions (approx. 20 minutes in EEG) in a dimly lit room. The experiment began with 20 practice trials of 10 non-moral words and 10 non-moral non-words with decreasing intervals of 300, 100, 60, 30, 16ms. Participants were instructed to sit 60cm away from the screen and rest their arms in a comfortable position.</p>
<p>The main experiment consisted of two blocks of trials, each containing 300 trials (75 words and 75 non-words for each category), for a total of 600 trials. The order of the blocks (Block A: moral or fashion first) is randomly determined for each participant. Participants had a short break after every 100 trials.</p>
<p>Each trial followed the same structure:</p>
<ol type="1">
<li>Fixation screen presented for 400-700ms</li>
<li>Stimulus (letter string) presented for 16.6ms</li>
<li>Fixation screen presented for 33.33ms</li>
<li>Backward mask of ampersands (&amp;) corresponding to the number of letters in the word, presented for 25ms</li>
<li>Blank screen presented for 1500ms for participant response</li>
</ol>
<p>Participants pressed the ‘1’ key if the string of letters appeared as a word and the ‘5’ key if it appeared as a non-word.</p>
<p>EEG Data was recorded from the Cz and Pz electrode, with additional sensors placed at C3, C4, P3, P4, Fz, F3, F4.</p>
</section>
<section id="osf-project-and-preregistration" class="level2">
<h2 class="anchored" data-anchor-id="osf-project-and-preregistration">OSF Project and Preregistration</h2>
<p>A preregistration for this study, stimuli and experiment scripts are available on the Open Science Framework at <a href="https://osf.io/9ygfj/" class="uri">https://osf.io/9ygfj/</a>.</p>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<section id="behavioral" class="level2">
<h2 class="anchored" data-anchor-id="behavioral">Behavioral</h2>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="This_files/figure-html/fig1-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Figure 1: Performance for in-category words and out-of-category words for each participant. Points above the diagonal represent higher accuracy for in-category words. Overall accuracy was much higher than expected. We later discovered this was due to a difference in procedure between our study and the original study. Lines represent +/- 1 SE.</figcaption>
</figure>
</div>
</div>
</div>
<p>A pop-out effect was found for fashion words, but not moral words.</p>
<p>In the moral condition, participants were 0.927451% accurate for moral words and 0.9164706% accurate for non-moral words. This difference was not statistically significant in the GEE model, β = -0.1528463, <em>SE =</em> 0.0925247, <em>z =</em> -1.651952, <em>p =</em> 0.0985443.</p>
<p>In the fashion condition, participants were 0.9290196% accurate for fashion words and 0.8835294% accurate for non-fashion words. This difference was not statistically significant in the GEE model, β = -0.5454404, <em>SE =</em> 0.1167027, <em>z =</em> -4.6737609, <em>p =</em> 2.9573357^{-6}.</p>
</section>
<section id="eeg" class="level2">
<h2 class="anchored" data-anchor-id="eeg">EEG</h2>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="This_files/figure-html/fig2-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Figure 2: Grand average waveforms. Shaded areas represent +/- 1 SE. Dotted Lines represent time windows of interest</figcaption>
</figure>
</div>
</div>
</div>
<section id="words-vs.-non-words" class="level3">
<h3 class="anchored" data-anchor-id="words-vs.-non-words">Words vs.&nbsp;Non-Words</h3>
<p>Following Gantman et al.&nbsp;(2020), we looked for word vs.&nbsp;non-word ERP effects at each time window at electrode Pz.</p>
<p>In the moral condition, words elicited a more positive ERP in the P2 window (β = 1.1811568, SE = 0.417889, z = 2.8264844, p = 0.0047062), N2 window (β = 2.1686034, SE = 0.4317908, z = 5.0223471, p = 5.1043823^{-7}), P3 window (β = 2.8105816, SE = 0.4912493, z = 5.7212939, p = 1.0571585^{-8}), and LPP window (β = -0.3005976, SE = 0.553326, z = -0.5432559, p = 0.5869536).</p>
<p>In the fashion condition, there was no significant difference in any of the time windows; P2 window (β = 0.4811835, SE = 0.476276, z = 1.0103038, p = 0.3123498), N2 window (β = 1.0654641, SE = 0.4815555, z = 2.2125466, p = 0.0269289), P3 window (β = 2.0034461, SE = 0.5402891, z = 3.7081005, p = 2.0881982^{-4}), and LPP window (β = -0.5776117, SE = 0.6061505, z = -0.9529179, p = 0.3406316).</p>
</section>
<section id="pop-out-effects" class="level3">
<h3 class="anchored" data-anchor-id="pop-out-effects">Pop-out effects</h3>
<p>Also following Gantman et al.&nbsp;(2020), we looked for ERP differences related to the category vs.&nbsp;non-category distinction in all four time windows at electrode Cz.</p>
<p>In the moral condition, there were no significant differences between moral and non-moral words in the P2 window (β = 0.0300243, SE = 0.3142755, z = 0.0955348, p = 0.92389), N2 window (β = 0.1524485, SE = 0.3240468, z = 0.4704523, p = 0.6380319), P3 window (β = 0.1170814, SE = 0.3763191, z = 0.3111228, p = 0.7557073), and LPP window (β = 0.3376174, SE = 0.4264656, z = 0.7916639, p = 0.4285567).</p>
<p>In the fashion condition, the fashion words elicited a more positive ERP than non-fashion words in the P3 (β = -0.7862622, SE = 0.5077601, z = -1.5484914, p = 0.121504). There was no significant difference in the P2 window (β = -0.0617087, SE = 0.4267863, z = -0.1445893, p = 0.8850351), N2 window (β = 0.0933452, SE = 0.4479022, z = 0.2084052, p = 0.8349126), and LPP window (β = -0.920732, SE = 0.5855168, z = -1.5725117, p = 0.1158319).</p>
</section>
</section>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<p>This replication study aimed to assess the generality and robustness of the moral pop-out effect as reported by Gantman et al.&nbsp;(2020), while taking into account potential confounding factors such as semantic priming. Our results provide partial support, with some notable differences.</p>
<p>Consistent with Gantman et al., we found evidence of a pop-out effect for fashion words but not for moral words in the behavioral data, with participants responding more accurately to fashion words compared to non-fashion words. However, contrary to the original study, a similar effect was not observed for moral words.</p>
<p>Our ERP results provide partial support for the moral pop-out effect, with moral words eliciting enhanced P2, N2, and P3 components compared to non-moral words.</p>
<p>One notable difference between our study and Gantman et al.&nbsp;is the overall accuracy. Participants in our sutdy responsed much more accurately in our study (~90%) compared to Gantman et al.&nbsp;(~70%). We later discovered this was due to a procedural change where stimuli were presented for a longer duration that the original study. This may have reduced the sensitivity of the task to detect significance between conditions. Taken together, our partial replication of Gantman et al (2020) suggests that while moral words may be processed differently than non-moral words under certain conditions, this ‘pop-out effect’ is likely due to procedural variations and merits further research. Furthermore, this replication highlights the importance of carefully understanding procedures when attempting to replicate an effect.</p>
</section>
<section id="limitations" class="level1">
<h1>Limitations</h1>
<p>It is important to acknowledge the limitations of our study and consider how it might inform future research. First, our sample consisted entirely of college students from a single institution, which may limit the generalizability of the findings, despite being similar to the participant demographic used by Gantman et al.&nbsp;(2020). Second, while we aimed to control potential confounds, such as semantic priming, there may be other factors that could influence the pop-out effect. Additionally, this study focused on a specific set of moral and fashion words. To further delve into the generalizability of the pop-out effect, future studies could utilize a wider range of stimuli (perhaps testing the pop-out effect in a study with more than 2 categories), with varying semantic categories and stimulus types (e.g, other forms of stimulus such as sound or images and diverse categories). Finally, and as mentioned previously, our analysis is limited due to the procedural misunderstanding that led to the experiment not being accurately replicated in design. Future iterations of this research should take this into account.</p>
<p>Ultimately, our study contributes to the ongoing debate about the nature of moral perception. These findings highlight the importance of replication and call attention to the importance for careful control of procedural variables.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<ol type="1">
<li><p>Firestone, C. &amp; Scholl, B. (2015). Enhanced visual awareness for morality and pajamas? Perception vs.&nbsp;memory in ‘top-down’ effects. Cognition, 136, 409-416.</p></li>
<li><p>Gantman, A., Devraj-Kizuk, S., Mende-Siedlecki, P., Van Bavel, J., &amp; Mathewson, K. (2020). The time course of moral perception: an ERP investigation of the moral pop-out effect. Social Cognitive and Affective Neuroscience, 15(2), 235-246.</p></li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>